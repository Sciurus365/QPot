---
title: "QPot: An R Package for Stochastic Differential Equation Quasi-Potential Analysis"
author:
  - "Christopher Moore, Chris Stieha, Ben Nolting, Maria Cameron, and Karen Abbott"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{4. Global quasi-potential calculation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r echo=FALSE, results=FALSE}
model.ex1 <- function(t, y, parameters) {
  x <- y[1]
  y <- y[2]
  alpha <- parameters["alpha"]
  beta <- parameters["beta"]
  delta <- parameters["delta"]
  kappa <- parameters["kappa"]
  gamma <- parameters["gamma"]
  mu <- parameters["mu"]
  dy <- numeric(2)
  dy[1] <- (alpha * x) * (1 - (x / beta)) - ((delta * (x^2) * y) / (kappa + (x^2)))
  dy[2] <- ((gamma * (x^2) * y) / (kappa + (x^2))) - mu * (y^2)
  list(dy)
}
model.parms <- c("alpha" = 1.54, "beta" = 10.14, "delta" = 1, "gamma" = 0.476, "mu" = 0.112509, "kappa" = 1)
library(package = "rootSolve")
xspace <- seq(from = 1, to = 5, length.out = 10)
yspace <- seq(from = 2.5, to = 4, length.out = 10)
l.xspace <- length(x = xspace)
l.yspace <- length(x = yspace)
space.mat <- matrix(data = NA, nrow = l.xspace * l.yspace, ncol = 2)

for (i in 1:l.xspace) {
  for (j in 1:l.yspace) {
    y <- c(x = xspace[i], y = yspace[j])
    STO <- stode(y = y, func = model.ex1, parms = model.parms, positive = T)
    space.mat[(((i - 1) * l.xspace) + j), ] <- STO$y
  }
}
eqs <- unique(x = round(x = space.mat, digits = 3))

library(QPot)
var.eqn.x <- "(alpha * x) * (1 - (x / beta)) - ((delta * (x^2) * y) / (kappa + (x^2)))"
var.eqn.y <- "((gamma * (x^2) * y) / (kappa + (x^2))) - mu * (y^2)"
model.parms <- c(alpha = 1.54, beta = 10.14, delta = 1, gamma = 0.476, kappa = 1, mu = 0.112509)
parms.eqn.x <- Model2String(model = var.eqn.x, parms = model.parms, supress.print = T)
parms.eqn.y <- Model2String(model = var.eqn.y, parms = model.parms, supress.print = T)

eq1.x <- eqs[1, 1]
eq1.y <- eqs[1, 2] # stable focus
eq2.x <- eqs[3, 1]
eq2.y <- eqs[3, 2] # stable node
bounds.x <- c(-0.5, 20.0)
bounds.y <- c(-0.5, 20.0)
step.number.x <- 1000
step.number.y <- 1000
eq1.local <- QPotential(x.rhs = parms.eqn.x, x.start = eq1.x, x.bound = bounds.x, x.num.steps = step.number.x, y.rhs = parms.eqn.y, y.start = eq1.y, y.bound = bounds.y, y.num.steps = step.number.y)

eq2.local <- QPotential(x.rhs = parms.eqn.x, x.start = eq2.x, x.bound = bounds.x, x.num.steps = step.number.x, y.rhs = parms.eqn.y, y.start = eq2.y, y.bound = bounds.y, y.num.steps = step.number.y)
```


Global quasi-potential calculation
========================================================
## Example 1 from Moore et al. (2016)
### Creating a global quasi-potential
The next step is combining the local quasi-potentials into a single surface.  If the system only has a single equilibrium point or basin of attraction (e.g., a limit cycle) then the local quasi-potential is the global quasi-potential.  If the system has two or more basins of attraction, then the local surfaces need to be aligned, adjusted, and combined.  Details can be found in Moore et al. (2016) and references therein, but we briefly describe what's happening in the function that creates the global quasi-potential, `QPGlobal`.

Briefly, the most probable way for a trajectory to transition from one basin to another involves passing through the lowest point on the surface specified by each local quasi-potential surface along the separatrix (the line between two basins of attraction). The two local quasi-potentials should be translated so that the minimum heights along the separatrix are the same.  In this example, the minima of both local quasi-potentials occurred at the same point---the saddle at $(4.201, 4.004)$---so the algorithm amounts to matching at that point.  This is a fairly straight-forward example, but see Moore et al. (2016), Example 3, for a more complicated example.

The functions that calculates the global quasi-potential is `QPGlobal`.  Its arguments minimally include:

1. a list of local surfaces,
2. the (x, y) locations of the unstable points to be evaluated, and
3. the boundaries used to calculate the local quasi-potentials.

For our example, we have:

```{r}
library(QPot)
unstable.x <- c(eqs[2, 1], eqs[4, 1]) # values are c(0, 4.2008)
unstable.y <- c(eqs[2, 2], eqs[4, 2]) # values are c(0, 4.0039)
ex1.global <- QPGlobal(local.surfaces = list(eq1.local, eq2.local), unstable.eq.x = unstable.x, unstable.eq.y = unstable.y, x.bound = bounds.x, y.bound = bounds.y)
```
And that's all she wrote---you've created your first global quasi-potential!
