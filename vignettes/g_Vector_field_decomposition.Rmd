---
title: "QPot: An R Package for Stochastic Differential Equation Quasi-Potential Analysis"
author:
  - "Christopher Moore, Chris Stieha, Ben Nolting, Maria Cameron, and Karen Abbott"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{6. Vector field decomposition}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE, results=FALSE}
model.ex1 <- function(t, y, parameters) {
  x <- y[1]
  y <- y[2]
  alpha <- parameters["alpha"]
  beta <- parameters["beta"]
  delta <- parameters["delta"]
  kappa <- parameters["kappa"]
  gamma <- parameters["gamma"]
  mu <- parameters["mu"]
  dy <- numeric(2)
  dy[1] <- (alpha * x) * (1 - (x / beta)) - ((delta * (x^2) * y) / (kappa + (x^2)))
  dy[2] <- ((gamma * (x^2) * y) / (kappa + (x^2))) - mu * (y^2)
  list(dy)
}
model.parms <- c("alpha" = 1.54, "beta" = 10.14, "delta" = 1, "gamma" = 0.476, "mu" = 0.112509, "kappa" = 1)
library(package = "rootSolve")
xspace <- seq(from = 1, to = 5, length.out = 10)
yspace <- seq(from = 2.5, to = 4, length.out = 10)
l.xspace <- length(x = xspace)
l.yspace <- length(x = yspace)
space.mat <- matrix(data = NA, nrow = l.xspace * l.yspace, ncol = 2)

for (i in 1:l.xspace) {
  for (j in 1:l.yspace) {
    y <- c(x = xspace[i], y = yspace[j])
    STO <- stode(y = y, func = model.ex1, parms = model.parms, positive = T)
    space.mat[(((i - 1) * l.xspace) + j), ] <- STO$y
  }
}
eqs <- unique(x = round(x = space.mat, digits = 3))

library(QPot)
var.eqn.x <- "(alpha * x) * (1 - (x / beta)) - ((delta * (x^2) * y) / (kappa + (x^2)))"
var.eqn.y <- "((gamma * (x^2) * y) / (kappa + (x^2))) - mu * (y^2)"
model.parms <- c(alpha = 1.54, beta = 10.14, delta = 1, gamma = 0.476, kappa = 1, mu = 0.112509)
parms.eqn.x <- Model2String(model = var.eqn.x, parms = model.parms, supress.print = T)
parms.eqn.y <- Model2String(model = var.eqn.y, parms = model.parms, supress.print = T)

eq1.x <- eqs[1, 1]
eq1.y <- eqs[1, 2] # stable focus
eq2.x <- eqs[3, 1]
eq2.y <- eqs[3, 2] # stable node
bounds.x <- c(-0.5, 20.0)
bounds.y <- c(-0.5, 20.0)
step.number.x <- 1000
step.number.y <- 1000
eq1.local <- QPotential(x.rhs = parms.eqn.x, x.start = eq1.x, x.bound = bounds.x, x.num.steps = step.number.x, y.rhs = parms.eqn.y, y.start = eq1.y, y.bound = bounds.y, y.num.steps = step.number.y)

eq2.local <- QPotential(x.rhs = parms.eqn.x, x.start = eq2.x, x.bound = bounds.x, x.num.steps = step.number.x, y.rhs = parms.eqn.y, y.start = eq2.y, y.bound = bounds.y, y.num.steps = step.number.y)

unstable.x <- c(eqs[2, 1], eqs[4, 1]) # values are c(0, 4.2008)
unstable.y <- c(eqs[2, 2], eqs[4, 2]) # values are c(0, 4.0039)
ex1.global <- QPGlobal(local.surfaces = list(eq1.local, eq2.local), unstable.eq.x = unstable.x, unstable.eq.y = unstable.y, x.bound = bounds.x, y.bound = bounds.y)
```

Vector field decomposition
========================================================
## Example 1 from Moore et al. (2016)
### Deterministic skeleton, gradient, and remainder fields
Recall that the deterministic skeleton from vignette [1. link here] can be visualized as a vector field. In gradient systems, this vector field is completely determined by the potential function. The name ``gradient system'' refers to the fact that the vector field is the negative of the potential function’s gradient.  In non-gradient systems, the vector field can no longer be represented solely in terms of the gradient.  Instead, there is a remainder component of the vector field. The vector field can be decomposed into two terms:
$$ \text{vector field} = \text{gradient (or negative of the potential)} + \text{remainder field} \text{, or}$$
$$
\begin{bmatrix}f_{1}(x,y)\\ f_{2}(x,y) \end{bmatrix}=-\nabla \Phi(x,y)+\mathbf{r}(x,y)= -\begin{bmatrix}\frac{\partial \Phi}{\partial x}(x,y)\\ \frac{\partial \Phi}{\partial y}(x,y) \end{bmatrix} + \begin{bmatrix}r_{1}(x,y)\\ r_{2}(x,y) \end{bmatrix}
$$
The remainder vector field is orthogonal to the gradient of the quasi-potential everywhere. That is, for every $(x, y)$ in the domain,
$$\nabla \Phi (x, y) · \mathbf{r}(x, y) = 0.$$
An more detailed explanation of this property can be found in Moore et al. (2016) and Nolting and Abbott (2016).

The remainder vector field can be interpreted as a force that causes trajectories to circulate around level sets of the quasi-potential.

### Vector field decomposition using `QPot`
`QPot` enables users to perform this decomposition. The function `VecDecomAll` calculates the vector field decomposition, and outputs three vector fields: the original deterministic skeleton, $\mathbf{f}(x, y)$; the gradient vector field, $-\nabla \Phi (x, y)$; and the remainder vector field, $\mathbf{r}(x, y)$. Each of these three vector fields can be output alone using `VecDecomVec`, `VecDecomGrad`, or `VecDecomRem`. These vector fields can be visualized using the function `VecDecomPlot`. Code to create the vector fields from `VecDecomAll` is displayed below; code for generating individual vector fields can be found in the man pages accessible by `help` for `VecDecomVec`, `VecDecomGrad`, or `VecDecomRem`. 

```{r}
library(QPot)
## Calculate all three vector fields.
VDAll <- VecDecomAll(surface = ex1.global, x.rhs = parms.eqn.x, y.rhs = parms.eqn.y, x.bound = bounds.x, y.bound = bounds.y)

## Plot the deterministic skeleton vector field
VecDecomPlot(x.field = VDAll[, , 1], y.field = VDAll[, , 2], dens = c(25, 25), x.bound = bounds.x, y.bound = bounds.y, xlim = c(0, 11), ylim = c(0, 6), arrow.type = "proportional", tail.length = 0.35, head.length = 0.025)
## Plot the gradient vector field
VecDecomPlot(x.field = VDAll[, , 3], y.field = VDAll[, , 4], dens = c(25, 25), x.bound = bounds.x, y.bound = bounds.y, arrow.type = "proportional", tail.length = 0.35, head.length = 0.025)
## Plot the remainder vector field
VecDecomPlot(x.field = VDAll[, , 5], y.field = VDAll[, , 6], dens = c(25, 25), x.bound = bounds.x, y.bound = bounds.y, arrow.type = "proportional", tail.length = 0.35, head.length = 0.025)
```

And that's it---you've successfully decomposed the vector field!
