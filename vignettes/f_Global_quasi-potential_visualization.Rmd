---
title: "QPot: An R Package for Stochastic Differential Equation Quasi-Potential Analysis"
author:
  - "Christopher Moore, Chris Stieha, Ben Nolting, Maria Cameron, and Karen Abbott"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{5. Global quasi-potential visualization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r echo=FALSE, results=FALSE}
model.ex1 <- function(t, y, parameters) {
  x <- y[1]
  y <- y[2]
  alpha <- parameters["alpha"]
  beta <- parameters["beta"]
  delta <- parameters["delta"]
  kappa <- parameters["kappa"]
  gamma <- parameters["gamma"]
  mu <- parameters["mu"]
  dy <- numeric(2)
  dy[1] <- (alpha * x) * (1 - (x / beta)) - ((delta * (x^2) * y) / (kappa + (x^2)))
  dy[2] <- ((gamma * (x^2) * y) / (kappa + (x^2))) - mu * (y^2)
  list(dy)
}
model.parms <- c("alpha" = 1.54, "beta" = 10.14, "delta" = 1, "gamma" = 0.476, "mu" = 0.112509, "kappa" = 1)
library(package = "rootSolve")
xspace <- seq(from = 1, to = 5, length.out = 10)
yspace <- seq(from = 2.5, to = 4, length.out = 10)
l.xspace <- length(x = xspace)
l.yspace <- length(x = yspace)
space.mat <- matrix(data = NA, nrow = l.xspace * l.yspace, ncol = 2)

for (i in 1:l.xspace) {
  for (j in 1:l.yspace) {
    y <- c(x = xspace[i], y = yspace[j])
    STO <- stode(y = y, func = model.ex1, parms = model.parms, positive = T)
    space.mat[(((i - 1) * l.xspace) + j), ] <- STO$y
  }
}
eqs <- unique(x = round(x = space.mat, digits = 3))

library(QPot)
var.eqn.x <- "(alpha * x) * (1 - (x / beta)) - ((delta * (x^2) * y) / (kappa + (x^2)))"
var.eqn.y <- "((gamma * (x^2) * y) / (kappa + (x^2))) - mu * (y^2)"
model.parms <- c(alpha = 1.54, beta = 10.14, delta = 1, gamma = 0.476, kappa = 1, mu = 0.112509)
parms.eqn.x <- Model2String(model = var.eqn.x, parms = model.parms, supress.print = T)
parms.eqn.y <- Model2String(model = var.eqn.y, parms = model.parms, supress.print = T)

eq1.x <- eqs[1, 1]
eq1.y <- eqs[1, 2] # stable focus
eq2.x <- eqs[3, 1]
eq2.y <- eqs[3, 2] # stable node
bounds.x <- c(-0.5, 20.0)
bounds.y <- c(-0.5, 20.0)
step.number.x <- 1000
step.number.y <- 1000
eq1.local <- QPotential(x.rhs = parms.eqn.x, x.start = eq1.x, x.bound = bounds.x, x.num.steps = step.number.x, y.rhs = parms.eqn.y, y.start = eq1.y, y.bound = bounds.y, y.num.steps = step.number.y)

eq2.local <- QPotential(x.rhs = parms.eqn.x, x.start = eq2.x, x.bound = bounds.x, x.num.steps = step.number.x, y.rhs = parms.eqn.y, y.start = eq2.y, y.bound = bounds.y, y.num.steps = step.number.y)

unstable.x <- c(eqs[2, 1], eqs[4, 1]) # values are c(0, 4.2008)
unstable.y <- c(eqs[2, 2], eqs[4, 2]) # values are c(0, 4.0039)
ex1.global <- QPGlobal(local.surfaces = list(eq1.local, eq2.local), unstable.eq.x = unstable.x, unstable.eq.y = unstable.y, x.bound = bounds.x, y.bound = bounds.y)
```

Global quasi-potential visualization
========================================================
## Example 1 from Moore et al. (2016)
### Visualizing local quasi-potential surfaces
Users can visualize the global quasi-potential surface right away, but we like to build in a little bit of anticipation and have users think about the local surfaces and what they expect to see in a global quasi-potential surface.

First, let's view the local quasi-potential surfaces with `QPContour`.
```{r}
library(QPot)
QPContour(surface = eq1.local, dens = c(1000, 1000), x.bound = bounds.x, y.bound = bounds.y)
QPContour(surface = eq2.local, dens = c(1000, 1000), x.bound = bounds.x, y.bound = bounds.y)
```

Notice that plotting contours is not very fast.  We have an argument, `dens`, that, when it's small, allows for faster plotting times.  This argument simply subsamples the surface.

Next, looking at the stable node's surface (`eqs[3,]`), you'll notice that there's not much resolution, and it looks like a large, flat basin.  Well, that's not the case.  The stable equilibrium is there, but it's a shallow depression that's too shallow to be captured by the color scheme and contour lines.  To see the depression, you could normally add more colors (`QPContour`) or add the number of contour lines, but that can be insufficient in many ways.  What we did to overcome this is create an argument within `QPContour` that changes the density of contour lines.  Specifically, the argument `c.parm` focuses the concentration of contour lines at that bottom of the basin, as the value increases from one.  Try, for example, the above with `c.parm = 2` or `c.parm = 5`:

```{r}
QPContour(surface = eq2.local, dens = c(1000, 1000), x.bound = bounds.x, y.bound = bounds.y, c.parm = 5)
```

This argument will come in handy, since the quasi-potential surfaces tend to span a large range, and we're often interested in the contours at the bottom of the basins.

### Visualizing the global quasi-potential surface
To visualize the global quasi-potential, one can simply take the global quasi-potential matrix from QPGlobal and use it to create a contour plot using `QPContour`.

```{r}
QPContour(surface = ex1.global, dens = c(1000, 1000), x.bound = bounds.x, y.bound = bounds.y)
```

That's it---you've created the global quasi-potential!

### Alternative means of visualizing the quasi-potential
There are many different ways of visualizing the 3-dimensional data like the quasi-potential surfaces.

Probably most useful, we suggest `persp3d` in package `rgl`.  This allows users to interact with the surface in 3 dimensions and gain a further understanding of the shape of the surface.
```{r, eval = F}
library("rgl")
persp3d(x = ex1.global, col = "#FF5500", xlab = "X", ylab = "Y", zlab = intToUtf8(0x03A6), xlim = c(0.05, 0.3), ylim = c(0.1, 0.3), zlim = c(0, 0.01))
```

Second, `image`, `contour`, and `filled.contour` are all `graphics` packages that work well with 3-dimensional data like the quasi-potential surfaces.  For example:

```{r}
image(x = ex1.global)
contour(x = ex1.global)
filled.contour(x = ex1.global)
```

Lastly, Karline Soetaert has written a package `plot3D` that has several other ways of visualizing the 3-dimensional data like the quasi-potential surfaces.  For example:

```{r, eval = F}
persp3D(z = ex1.global, contour = F)
```
